use {
    crate::{
        server::protocol::{h1::RequestBody as H1Body, h2::RequestBody as H2Body},
        util::MapAsyncOptExt,
    },
    bytes::{Buf, Bytes},
    futures::{Async, Poll},
    http::HeaderMap,
    std::fmt,
    tokio_buf::{BufStream, SizeHint},
};

/// A trait that abstracts HTTP request/response bodies.
pub trait HttpBody {
    /// The type of bytes generated by this body.
    type Data: Buf;

    /// The error type that will be returned from this body.
    type Error;

    /// Polls the next data of this body.
    fn poll_data(&mut self) -> Poll<Option<Self::Data>, Self::Error>;

    /// Returns the hint of remaining length of data.
    fn size_hint(&self) -> SizeHint {
        SizeHint::new()
    }

    /// Polls the trailing header map of this body.
    fn poll_trailers(&mut self) -> Poll<Option<HeaderMap>, Self::Error> {
        Ok(Async::Ready(None))
    }

    /// Returns whether the body has been completed emitting all chunks and trailer headers.
    ///
    /// It is possible that this method returns `false`
    /// even if the body has incomplete chunks or trailers.
    fn is_end_stream(&self) -> bool {
        false
    }

    /// Returns the length of total bytes contained in this body.
    fn content_length(&self) -> Option<u64> {
        let hint = self.size_hint();
        match hint.upper() {
            Some(u) if u == hint.lower() => Some(u),
            _ => None,
        }
    }
}

impl<T: BufStream> HttpBody for T {
    type Data = T::Item;
    type Error = T::Error;

    fn poll_data(&mut self) -> Poll<Option<Self::Data>, Self::Error> {
        BufStream::poll_buf(self)
    }

    fn size_hint(&self) -> SizeHint {
        BufStream::size_hint(self)
    }

    fn poll_trailers(&mut self) -> Poll<Option<HeaderMap>, Self::Error> {
        Ok(Async::Ready(None))
    }

    fn is_end_stream(&self) -> bool {
        let hint = self.size_hint();
        hint.upper()
            .map(|u| u == 0 && u == hint.lower())
            .unwrap_or(false)
    }
}

// ===== HttpBodyExt =====

/// An extension trait for adding some adaptor methods to `HttpBody`s.
pub trait HttpBodyExt: HttpBody {
    /// Lift this body into a `BufStream`.
    fn into_buf_stream(self) -> IntoBufStream<Self>
    where
        Self: Sized,
    {
        IntoBufStream { inner: self }
    }
}

impl<T: HttpBody> HttpBodyExt for T {}

/// A wrapper for `HttpBody` for lifting the instance into a `BufStream`.
#[derive(Debug)]
pub struct IntoBufStream<T: HttpBody> {
    inner: T,
}

impl<T: HttpBody> BufStream for IntoBufStream<T> {
    type Item = T::Data;
    type Error = T::Error;

    #[inline]
    fn poll_buf(&mut self) -> Poll<Option<Self::Item>, Self::Error> {
        HttpBody::poll_data(&mut self.inner)
    }

    #[inline]
    fn size_hint(&self) -> SizeHint {
        HttpBody::size_hint(&self.inner)
    }
}

// ===== Body =====

trait BoxedHttpBody: Send + 'static {
    fn poll_data(&mut self) -> Poll<Option<Data>, Error>;
    fn poll_trailers(&mut self) -> Poll<Option<http::HeaderMap>, Error>;
    fn size_hint(&self) -> tokio_buf::SizeHint;
    fn is_end_stream(&self) -> bool;
    fn content_length(&self) -> Option<u64>;
}

impl<B> BoxedHttpBody for B
where
    B: HttpBody + Send + 'static,
    B::Data: Send + 'static,
    B::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
{
    fn poll_data(&mut self) -> Poll<Option<Data>, Error> {
        HttpBody::poll_data(self)
            .map_async_opt(Data::from_buf)
            .map_err(Error::from_std)
    }

    fn poll_trailers(&mut self) -> Poll<Option<http::HeaderMap>, Error> {
        HttpBody::poll_trailers(self).map_err(Error::from_std)
    }

    fn size_hint(&self) -> tokio_buf::SizeHint {
        HttpBody::size_hint(self)
    }

    fn is_end_stream(&self) -> bool {
        HttpBody::is_end_stream(self)
    }

    fn content_length(&self) -> Option<u64> {
        HttpBody::content_length(self)
    }
}

pub struct Body(BodyInner);

enum BodyInner {
    Empty,
    Sized(Option<Bytes>),
    H1(H1Body),
    H2(H2Body),
}

impl fmt::Debug for Body {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Body").finish()
    }
}

impl Default for Body {
    fn default() -> Self {
        Self::empty()
    }
}

impl Body {
    /// Creates an empty `Body`.
    #[inline]
    pub fn empty() -> Self {
        Body(BodyInner::Empty)
    }
}

impl From<()> for Body {
    fn from(_: ()) -> Self {
        Body::empty()
    }
}

macro_rules! impl_response_body {
    ($($t:ty,)*) => {$(
        impl From<$t> for Body {
            fn from(body: $t) -> Self {
                Body(BodyInner::Sized(Some(body.into())))
            }
        }
    )*};
}

impl_response_body! {
    &'static str,
    &'static [u8],
    String,
    Vec<u8>,
    bytes::Bytes,
    //std::borrow::Cow<'static, str>,
    //std::borrow::Cow<'static, [u8]>,
}

impl From<H1Body> for Body {
    fn from(body: H1Body) -> Self {
        Body(BodyInner::H1(body))
    }
}

impl From<H2Body> for Body {
    fn from(body: H2Body) -> Self {
        Body(BodyInner::H2(body))
    }
}

impl HttpBody for Body {
    type Data = Data;
    type Error = Error;

    fn poll_data(&mut self) -> Poll<Option<Self::Data>, Self::Error> {
        match self.0 {
            BodyInner::Empty => Ok(Async::Ready(None)),
            BodyInner::Sized(ref mut data) => Ok(Async::Ready(data.take().map(Into::into))),
            BodyInner::H1(ref mut body) => HttpBody::poll_data(body)
                .map_async_opt(Data::from_buf)
                .map_err(Error::from_std),
            BodyInner::H2(ref mut body) => HttpBody::poll_data(body)
                .map_async_opt(Data::from_buf)
                .map_err(Error::from_std),
        }
    }

    fn size_hint(&self) -> SizeHint {
        let mut hint = SizeHint::new();
        match self.0 {
            BodyInner::Empty => hint.set_upper(0),
            BodyInner::Sized(Some(ref data)) => hint.set_upper(data.len() as u64),
            BodyInner::Sized(..) => (),
            BodyInner::H1(ref body) => return HttpBody::size_hint(body),
            BodyInner::H2(ref body) => return HttpBody::size_hint(body),
        }
        hint
    }

    fn poll_trailers(&mut self) -> Poll<Option<HeaderMap>, Self::Error> {
        match self.0 {
            BodyInner::H1(ref mut body) => HttpBody::poll_trailers(body).map_err(Error::from_std),
            BodyInner::H2(ref mut body) => HttpBody::poll_trailers(body).map_err(Error::from_std),
            _ => Ok(Async::Ready(None)),
        }
    }

    fn is_end_stream(&self) -> bool {
        match self.0 {
            BodyInner::Empty => true,
            BodyInner::Sized(ref data) => data.as_ref().map_or(true, Bytes::is_empty),
            BodyInner::H1(ref body) => HttpBody::is_end_stream(body),
            BodyInner::H2(ref body) => HttpBody::is_end_stream(body),
        }
    }

    fn content_length(&self) -> Option<u64> {
        match self.0 {
            BodyInner::Sized(Some(ref data)) => Some(data.len() as u64),
            BodyInner::H1(ref body) => HttpBody::content_length(body),
            BodyInner::H2(ref body) => HttpBody::content_length(body),
            _ => None,
        }
    }
}

// ===== Data =====

/// A chunk of bytes produced by `ResponseBody`.
#[derive(Debug)]
pub struct Data(DataInner);

enum DataInner {
    Bytes(Bytes),
    Boxed(Box<dyn Buf + Send + 'static>),
}

impl fmt::Debug for DataInner {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DataInner::Bytes(..) => f.debug_struct("Bytes").finish(),
            DataInner::Boxed(..) => f.debug_struct("Boxed").finish(),
        }
    }
}

impl Data {
    #[allow(missing_docs)]
    pub fn from_buf<B>(data: B) -> Self
    where
        B: Buf + Send + 'static,
    {
        Data(DataInner::Boxed(Box::new(data)))
    }
}

impl From<Bytes> for Data {
    fn from(data: Bytes) -> Self {
        Data(DataInner::Bytes(data))
    }
}

impl Buf for Data {
    fn remaining(&self) -> usize {
        match self.0 {
            DataInner::Bytes(ref data) => data.len(),
            DataInner::Boxed(ref data) => data.remaining(),
        }
    }

    fn bytes(&self) -> &[u8] {
        match self.0 {
            DataInner::Bytes(ref data) => data.as_ref(),
            DataInner::Boxed(ref data) => data.bytes(),
        }
    }

    fn advance(&mut self, cnt: usize) {
        match self.0 {
            DataInner::Bytes(ref mut data) => data.advance(cnt),
            DataInner::Boxed(ref mut data) => data.advance(cnt),
        }
    }
}

impl AsRef<[u8]> for Data {
    fn as_ref(&self) -> &[u8] {
        self.bytes()
    }
}

// ===== Error =====

type BoxedStdError = Box<dyn std::error::Error + Send + Sync + 'static>;

/// The type of error values caused by `Body`.
#[derive(Debug)]
pub struct Error(BoxedStdError);

impl Error {
    fn from_std(err: impl Into<BoxedStdError>) -> Self {
        Error(err.into())
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        Some(&*self.0)
    }
}

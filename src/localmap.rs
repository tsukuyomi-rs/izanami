//! An implementation of typemap for managing request-local data.

use std::{
    any::TypeId,
    collections::{hash_map, HashMap},
    fmt,
    hash::{BuildHasherDefault, Hasher},
    marker::PhantomData,
};

pub use crate::local_key;

/// A macro to create a `LocalKey<T>`.
#[macro_export]
macro_rules! local_key {
    ($(#[$m:meta])* $vis:vis static $NAME:ident : $t:ty; $($tail:tt)*) => {
        local_key!(@declare $(#[$m])* ($vis) static $NAME: $t);
        local_key!($($tail)*);
    };

    ($(#[$m:meta])* $vis:vis const $NAME:ident : $t:ty; $($tail:tt)*) => {
        local_key!(@declare $(#[$m])* ($vis) const $NAME: $t);
        local_key!($($tail)*);
    };

    () => ();

    (@declare $(#[$m:meta])* ($($vis:tt)*) $kw:tt $NAME:ident : $t:ty) => {
        $(#[$m])*
        $($vis)* $kw $NAME: $crate::localmap::LocalKey<$t> = {
            fn __key_id() -> $crate::localmap::KeyId {
                struct __A;
                $crate::localmap::KeyId::new::<__A>()
            }
            $crate::localmap::LocalKey {
                __key_id,
                __marker: std::marker::PhantomData,
            }
        };
    };
}

/// A type representing a key for request-local data stored in a `LocalMap`.
///
/// The value of this type are generated by the `local_key!` macro.
pub struct LocalKey<T: Send + 'static> {
    // not a public API.
    #[doc(hidden)]
    pub __key_id: fn() -> KeyId,
    // not a public API.
    #[doc(hidden)]
    pub __marker: PhantomData<fn() -> T>,
}

impl<T: Send + 'static> fmt::Debug for LocalKey<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("LocalKey").finish()
    }
}

impl<T: Send + 'static> Copy for LocalKey<T> {}

impl<T: Send + 'static> Clone for LocalKey<T> {
    fn clone(&self) -> Self {
        *self
    }
}

/// A trait that behaves as a `LocalKey`.
pub trait AsLocalKey {
    /// The data type associated with this key.
    type Data: Send + 'static;

    /// Returns the identifier representation of this key.
    fn id(&self) -> KeyId;
}

impl<T: Send + 'static> AsLocalKey for LocalKey<T> {
    type Data = T;

    fn id(&self) -> KeyId {
        (self.__key_id)()
    }
}

impl<'a, T: ?Sized> AsLocalKey for &'a T
where
    T: AsLocalKey,
{
    type Data = T::Data;

    fn id(&self) -> KeyId {
        (*self).id()
    }
}

/// Identifier of `LocalKey`s.
#[derive(Debug, PartialEq, Eq, Hash)]
pub struct KeyId(TypeId);

impl KeyId {
    // not a public API.
    #[doc(hidden)]
    #[inline]
    pub fn new<T: Send + 'static>() -> Self {
        KeyId(TypeId::of::<T>())
    }
}

/// A trait representing a data to be stored in `LocalMap`s.
pub trait LocalData: Sized + Send + 'static {
    /// The value of `LocalKey` associated with this type.
    const KEY: LocalKey<Self>;

    /// Acquires a reference to `Self` stored in the specified localmap.
    fn borrow(map: &LocalMap) -> Option<&Self> {
        map.get(Self::KEY)
    }

    /// Acquires a mutable reference to `Self` stored in the specified localmap.
    fn borrow_mut(map: &mut LocalMap) -> Option<&mut Self> {
        map.get_mut(Self::KEY)
    }

    /// Returns `true` if a value of `Self` is stored in the specified localmap.
    fn contains(map: &LocalMap) -> bool {
        map.contains_key(Self::KEY)
    }

    /// Extracts the instance of `Self` stored in the specified localmap.
    fn take_from(map: &mut LocalMap) -> Option<Self> {
        map.remove(Self::KEY)
    }

    /// Stores itself into the specified localmap.
    fn insert_into(self, map: &mut LocalMap) -> Option<Self> {
        map.insert(Self::KEY, self)
    }

    /// Creates an `Entry` for in-place manipulation corresponds
    /// to an entry of `Self` in the specified map.
    fn entry(map: &mut LocalMap) -> Entry<'_, LocalKey<Self>> {
        map.entry(Self::KEY)
    }
}

struct IdentHasher(u64);

impl Default for IdentHasher {
    fn default() -> Self {
        IdentHasher(0)
    }
}

impl Hasher for IdentHasher {
    fn finish(&self) -> u64 {
        self.0
    }

    fn write(&mut self, bytes: &[u8]) {
        for &b in bytes {
            self.write_u8(b);
        }
    }

    fn write_u8(&mut self, i: u8) {
        self.0 = (self.0 << 8) | u64::from(i);
    }

    fn write_u64(&mut self, i: u64) {
        self.0 = i;
    }
}

trait Opaque: Send + 'static {}

impl<T: Send + 'static> Opaque for T {}

impl fmt::Debug for dyn Opaque {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str("Opaque { ... }")
    }
}

impl dyn Opaque {
    unsafe fn downcast_ref_unchecked<T: Send + 'static>(&self) -> &T {
        &*(self as *const dyn Opaque as *const T)
    }

    unsafe fn downcast_mut_unchecked<T: Send + 'static>(&mut self) -> &mut T {
        &mut *(self as *mut dyn Opaque as *mut T)
    }

    unsafe fn downcast_unchecked<T: Send + 'static>(self: Box<Self>) -> Box<T> {
        Box::from_raw(Box::into_raw(self) as *mut T)
    }
}

/// A typed map storing request-local data.
#[derive(Debug, Default)]
pub struct LocalMap {
    inner: HashMap<KeyId, Box<dyn Opaque>, BuildHasherDefault<IdentHasher>>,
}

impl LocalMap {
    /// Returns a shared reference to the value corresponding to the provided `LocalKey`.
    pub fn get<K>(&self, key: K) -> Option<&K::Data>
    where
        K: AsLocalKey,
    {
        Some(unsafe { self.inner.get(&key.id())?.downcast_ref_unchecked() })
    }

    /// Returns a mutable reference to the value corresponding to the provided `LocalKey`.
    pub fn get_mut<K>(&mut self, key: K) -> Option<&mut K::Data>
    where
        K: AsLocalKey,
    {
        Some(unsafe { self.inner.get_mut(&key.id())?.downcast_mut_unchecked() })
    }

    /// Returns `true` if the map contains a value for the specified `LocalKey`.
    pub fn contains_key<K>(&self, key: K) -> bool
    where
        K: AsLocalKey,
    {
        self.inner.contains_key(&key.id())
    }

    /// Inserts a value corresponding to the provided `LocalKey` into the map.
    pub fn insert<K>(&mut self, key: K, value: K::Data) -> Option<K::Data>
    where
        K: AsLocalKey,
    {
        Some(unsafe {
            *self
                .inner
                .insert(key.id(), Box::new(value))?
                .downcast_unchecked()
        })
    }

    /// Removes a value corresponding to the provided `LocalKey` from the map.
    pub fn remove<K>(&mut self, key: K) -> Option<K::Data>
    where
        K: AsLocalKey,
    {
        Some(unsafe { *self.inner.remove(&key.id())?.downcast_unchecked() })
    }

    /// Create a `Entry` for in-place manipulation corresponds to an entry in the map.
    pub fn entry<K>(&mut self, key: K) -> Entry<'_, K>
    where
        K: AsLocalKey,
    {
        match self.inner.entry(key.id()) {
            hash_map::Entry::Occupied(inner) => Entry::Occupied(OccupiedEntry { inner, key }),
            hash_map::Entry::Vacant(inner) => Entry::Vacant(VacantEntry { inner, key }),
        }
    }
}

/// A view into a single entry in a `LocalMap`.
pub enum Entry<'a, K: AsLocalKey> {
    /// An occupied entry.
    Occupied(OccupiedEntry<'a, K>),
    /// A vacant entry.
    Vacant(VacantEntry<'a, K>),
}

impl<'a, K> fmt::Debug for Entry<'a, K>
where
    K: AsLocalKey,
    K::Data: fmt::Debug,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Entry::Occupied(ref e) => f.debug_tuple("Occupied").field(e).finish(),
            Entry::Vacant(ref e) => f.debug_tuple("Vacant").field(e).finish(),
        }
    }
}

impl<'a, K> Entry<'a, K>
where
    K: AsLocalKey,
{
    #[allow(missing_docs)]
    pub fn or_insert(self, default: K::Data) -> &'a mut K::Data {
        self.or_insert_with(|| default)
    }

    #[allow(missing_docs)]
    pub fn or_insert_with<F>(self, default: F) -> &'a mut K::Data
    where
        F: FnOnce() -> K::Data,
    {
        match self {
            Entry::Occupied(entry) => entry.into_mut(),
            Entry::Vacant(entry) => entry.insert(default()),
        }
    }

    #[allow(missing_docs)]
    pub fn or_default(self) -> &'a mut K::Data
    where
        K::Data: Default,
    {
        self.or_insert_with(Default::default)
    }

    #[allow(missing_docs)]
    pub fn key(&self) -> &K {
        match self {
            Entry::Occupied(entry) => entry.key(),
            Entry::Vacant(entry) => entry.key(),
        }
    }

    #[allow(missing_docs)]
    pub fn and_modify<F>(self, f: F) -> Self
    where
        F: FnOnce(&mut K::Data),
    {
        match self {
            Entry::Occupied(mut entry) => {
                f(entry.get_mut());
                Entry::Occupied(entry)
            }
            Entry::Vacant(entry) => Entry::Vacant(entry),
        }
    }
}

/// An occupied entry.
pub struct OccupiedEntry<'a, K: AsLocalKey> {
    inner: hash_map::OccupiedEntry<'a, KeyId, Box<dyn Opaque>>,
    key: K,
}

#[cfg_attr(tarpaulin, skip)]
impl<'a, K> fmt::Debug for OccupiedEntry<'a, K>
where
    K: AsLocalKey,
    K::Data: fmt::Debug,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_tuple("OccupiedEntry").field(self.get()).finish()
    }
}

#[allow(missing_docs)]
impl<'a, K> OccupiedEntry<'a, K>
where
    K: AsLocalKey,
{
    pub fn key(&self) -> &K {
        &self.key
    }

    pub fn remove_entry(self) -> (K, K::Data) {
        let data = unsafe { *self.inner.remove().downcast_unchecked() };
        (self.key, data)
    }

    pub fn get(&self) -> &K::Data {
        unsafe { self.inner.get().downcast_ref_unchecked() }
    }

    pub fn get_mut(&mut self) -> &mut K::Data {
        unsafe { self.inner.get_mut().downcast_mut_unchecked() }
    }

    pub fn into_mut(self) -> &'a mut K::Data {
        unsafe { self.inner.into_mut().downcast_mut_unchecked() }
    }

    pub fn insert(&mut self, value: K::Data) -> K::Data {
        unsafe { *self.inner.insert(Box::new(value)).downcast_unchecked() }
    }

    pub fn remove(self) -> K::Data {
        self.remove_entry().1
    }
}

/// A vacant entry.
pub struct VacantEntry<'a, K: AsLocalKey> {
    inner: hash_map::VacantEntry<'a, KeyId, Box<dyn Opaque>>,
    key: K,
}

#[cfg_attr(tarpaulin, skip)]
impl<'a, K> fmt::Debug for VacantEntry<'a, K>
where
    K: AsLocalKey,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("VacantEntry").finish()
    }
}

#[allow(missing_docs)]
impl<'a, K> VacantEntry<'a, K>
where
    K: AsLocalKey,
{
    pub fn key(&self) -> &K {
        &self.key
    }

    pub fn into_key(self) -> K {
        self.key
    }

    pub fn insert(self, default: K::Data) -> &'a mut K::Data {
        unsafe {
            self.inner
                .insert(Box::new(default))
                .downcast_mut_unchecked()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn smoke_test() {
        let mut map = LocalMap::default();

        local_key! {
            static KEY: String;
        }

        assert!(!map.contains_key(KEY));

        assert!(map.insert(KEY, String::from("foo")).is_none());
        assert!(map.contains_key(KEY));

        assert_eq!(map.get(KEY), Some(&"foo".into()));

        assert_eq!(map.insert(KEY, String::from("bar")), Some("foo".into()));
        assert!(map.contains_key(KEY));

        assert_eq!(map.get(KEY), Some(&"bar".into()));

        assert_eq!(map.remove(KEY), Some("bar".into()));
        assert!(!map.contains_key(KEY));
    }

    #[test]
    fn entry_or_insert() {
        let mut map = LocalMap::default();

        local_key! {
            static KEY: String;
        }

        map.entry(KEY).or_insert("foo".into());
        assert_eq!(map.get(KEY), Some(&"foo".into()));

        map.entry(KEY).or_insert("bar".into());
        assert_eq!(map.get(KEY), Some(&"foo".into()));
    }

    #[test]
    fn entry_and_modify() {
        let mut map = LocalMap::default();

        local_key! {
            static KEY: String;
        }

        map.entry(KEY).and_modify(|s| {
            *s += "foo";
        });
        assert!(!map.contains_key(KEY));

        map.insert(KEY, "foo".into());

        map.entry(KEY).and_modify(|s| {
            *s += "bar";
        });
        assert_eq!(map.get(KEY), Some(&"foobar".into()));

        map.entry(KEY).and_modify(|s| {
            *s += "baz";
        });
        assert_eq!(map.get(KEY), Some(&"foobarbaz".into()));
    }

    #[test]
    fn occupied_entry() {
        let mut map = LocalMap::default();

        local_key! {
            static KEY: String;
        }

        map.insert(KEY, "foo".into());

        if let Entry::Occupied(mut entry) = map.entry(KEY) {
            assert_eq!(entry.get(), "foo");
            assert_eq!(entry.insert("bar".into()), "foo");
            assert_eq!(entry.get(), "bar");
            assert_eq!(entry.remove(), "bar");
        }

        assert!(!map.contains_key(KEY));
    }

    #[test]
    fn local_key_const() {
        local_key! {
            const KEY: String;
        }

        let mut map = LocalMap::default();
        map.insert(KEY, "foo".into());
        assert!(map.contains_key(KEY));
    }

    #[test]
    fn local_key_ref() {
        local_key! {
            const KEY: String;
        }

        let mut map = LocalMap::default();
        map.insert(&KEY, "foo".into());
        assert!(map.contains_key(&KEY));
    }

    #[test]
    fn local_data() {
        #[derive(Debug, PartialEq)]
        struct SessionKey(String);

        impl LocalData for SessionKey {
            local_key! {
                const KEY: Self;
            }
        }

        let mut map = LocalMap::default();
        SessionKey("foo".into()).insert_into(&mut map);
        assert!(SessionKey::contains(&map));
        assert_eq!(SessionKey::borrow(&map), Some(&SessionKey("foo".into())));
    }
}

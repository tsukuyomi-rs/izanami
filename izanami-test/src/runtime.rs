use {
    crate::{
        output::Output,
        service::{MakeTestService, TestService},
        CritError,
    },
    bytes::{Buf, Bytes},
    futures::{Async, Future, Poll},
    http::Response,
    izanami_util::buf_stream::BufStream,
    std::{
        mem,
        panic::{resume_unwind, AssertUnwindSafe},
    },
};

/// A trait that abstracts the runtime for executing asynchronous computations
/// generated by the specified `Service`.
pub trait Runtime<S>: RuntimeImpl<S>
where
    S: MakeTestService,
{
}

pub trait RuntimeImpl<S>
where
    S: MakeTestService,
{
    fn make_service(&mut self, future: S::Future) -> crate::Result<S::Service>;

    fn call(
        &mut self,
        future: <S::Service as TestService>::Future,
    ) -> crate::Result<Response<Output>>;

    fn shutdown(self);
}

fn block_on<F>(runtime: &mut tokio::runtime::Runtime, future: F) -> Result<F::Item, F::Error>
where
    F: Future + Send + 'static,
    F::Item: Send + 'static,
    F::Error: Send + 'static,
{
    match runtime.block_on(AssertUnwindSafe(future).catch_unwind()) {
        Ok(result) => result,
        Err(err) => resume_unwind(Box::new(err)),
    }
}

impl<S> Runtime<S> for tokio::runtime::Runtime
where
    S: MakeTestService,
    S::Service: Send + 'static,
    <S::Service as TestService>::Future: Send + 'static,
    S::Future: Send + 'static,
    S::ResponseBody: BufStream + Send + 'static,
    <S::ResponseBody as BufStream>::Error: Into<CritError>,
{
}

impl<S> RuntimeImpl<S> for tokio::runtime::Runtime
where
    S: MakeTestService,
    S::Service: Send + 'static,
    <S::Service as TestService>::Future: Send + 'static,
    S::Future: Send + 'static,
    S::ResponseBody: BufStream + Send + 'static,
    <S::ResponseBody as BufStream>::Error: Into<CritError>,
{
    fn make_service(&mut self, mut future: S::Future) -> crate::Result<S::Service> {
        block_on(
            self,
            futures::future::poll_fn(move || future.poll().map_err(Into::into)),
        )
        .map_err(failure::Error::from_boxed_compat)
        .map_err(Into::into)
    }

    fn call(
        &mut self,
        mut future: <S::Service as TestService>::Future,
    ) -> crate::Result<Response<Output>> {
        let (parts, body) = block_on(
            self,
            futures::future::poll_fn(move || {
                future
                    .poll()
                    .map_err(Into::into)
                    .map_err(failure::Error::from_boxed_compat)
            }),
        )?
        .into_parts();

        let output = block_on(
            self,
            Receive {
                state: ReceiveState::Init(Some(body)),
            },
        )?;

        Ok(Response::from_parts(parts, output))
    }

    fn shutdown(self) {
        self.shutdown_on_idle().wait().unwrap();
    }
}

impl<S> Runtime<S> for tokio::runtime::current_thread::Runtime
where
    S: MakeTestService,
    <S::ResponseBody as BufStream>::Error: Into<CritError>,
{
}

impl<S> RuntimeImpl<S> for tokio::runtime::current_thread::Runtime
where
    S: MakeTestService,
    <S::ResponseBody as BufStream>::Error: Into<CritError>,
{
    fn make_service(&mut self, future: S::Future) -> crate::Result<S::Service> {
        self.block_on(future)
            .map_err(|err| failure::Error::from_boxed_compat(err.into()))
            .map_err(Into::into)
    }

    fn call(
        &mut self,
        mut future: <S::Service as TestService>::Future,
    ) -> crate::Result<Response<Output>> {
        let (parts, body) = self
            .block_on(futures::future::poll_fn(move || {
                future
                    .poll()
                    .map_err(Into::into)
                    .map_err(failure::Error::from_boxed_compat)
            }))?
            .into_parts();

        let output = self.block_on(Receive {
            state: ReceiveState::Init(Some(body)),
        })?;

        Ok(Response::from_parts(parts, output))
    }

    fn shutdown(mut self) {
        self.run().unwrap();
    }
}

#[allow(missing_debug_implementations)]
struct Receive<Bd> {
    state: ReceiveState<Bd>,
}

#[allow(missing_debug_implementations)]
enum ReceiveState<Bd> {
    Init(Option<Bd>),
    InFlight { body: Bd, chunks: Vec<Bytes> },
}

impl<Bd> Future for Receive<Bd>
where
    Bd: BufStream,
    Bd::Error: Into<CritError>,
{
    type Item = Output;
    type Error = crate::Error;

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        loop {
            self.state = match self.state {
                ReceiveState::Init(ref mut body) => ReceiveState::InFlight {
                    body: body.take().expect("unexpected condition"),
                    chunks: vec![],
                },
                ReceiveState::InFlight {
                    ref mut body,
                    ref mut chunks,
                } => {
                    while let Some(chunk) = futures::try_ready!({
                        body.poll_buf()
                            .map_err(Into::into)
                            .map_err(failure::Error::from_boxed_compat)
                    }) {
                        chunks.push(chunk.collect());
                    }
                    return Ok(Async::Ready(Output {
                        chunks: mem::replace(chunks, vec![]),
                    }));
                }
            }
        }
    }
}

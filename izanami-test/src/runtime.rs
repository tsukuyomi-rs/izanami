use {
    crate::{
        error::BoxedStdError,
        output::Output,
        service::{MakeTestService, ResponseBody, TestService},
    },
    bytes::{Buf, Bytes},
    futures::{Async, Future, Poll},
    http::Response,
    std::{
        mem,
        panic::{resume_unwind, AssertUnwindSafe},
    },
};

/// A trait that abstracts the runtime for executing asynchronous computations
/// generated by the specified `Service`.
pub trait Runtime<S>: RuntimeImpl<S>
where
    S: MakeTestService,
{
}

#[doc(hidden)]
pub trait RuntimeImpl<S>
where
    S: MakeTestService,
{
    fn make_service(&mut self, future: S::Future) -> crate::Result<S::Service>;

    fn call(
        &mut self,
        future: <S::Service as TestService>::Future,
    ) -> crate::Result<Response<S::ResponseBody>>;

    fn receive_body(&mut self, body: S::ResponseBody) -> crate::Result<Output>;

    fn shutdown(self);
}

/// An implementor of `Runtime<S>` using the default Tokio runtime.
#[derive(Debug)]
pub struct DefaultRuntime {
    runtime: tokio::runtime::Runtime,
}

impl DefaultRuntime {
    pub(crate) fn new() -> crate::Result<Self> {
        let mut builder = tokio::runtime::Builder::new();
        builder.core_threads(1);
        builder.blocking_threads(1);
        builder.name_prefix("izanami-test");

        Ok(Self {
            runtime: builder.build()?,
        })
    }

    fn block_on<F>(&mut self, mut future: F) -> crate::Result<F::Item>
    where
        F: Future + Send + 'static,
        F::Item: Send + 'static,
        F::Error: Into<BoxedStdError>,
    {
        let future = futures::future::poll_fn(move || {
            future.poll().map_err(crate::Error::from_boxed_compat)
        });
        match self
            .runtime
            .block_on(AssertUnwindSafe(future).catch_unwind())
        {
            Ok(result) => result,
            Err(err) => resume_unwind(Box::new(err)),
        }
    }
}

impl<S> Runtime<S> for DefaultRuntime
where
    S: MakeTestService,
    S::Service: Send + 'static,
    <S::Service as TestService>::Future: Send + 'static,
    S::Future: Send + 'static,
    S::ResponseBody: Send + 'static,
{
}

impl<S> RuntimeImpl<S> for DefaultRuntime
where
    S: MakeTestService,
    S::Service: Send + 'static,
    <S::Service as TestService>::Future: Send + 'static,
    S::Future: Send + 'static,
    S::ResponseBody: Send + 'static,
{
    fn make_service(&mut self, future: S::Future) -> crate::Result<S::Service> {
        self.block_on(future)
    }

    fn call(
        &mut self,
        future: <S::Service as TestService>::Future,
    ) -> crate::Result<Response<S::ResponseBody>> {
        self.block_on(future)
    }

    fn receive_body(&mut self, body: S::ResponseBody) -> crate::Result<Output> {
        self.block_on(Receive::new(body))
    }

    fn shutdown(self) {
        self.runtime.shutdown_on_idle().wait().unwrap();
    }
}

/// An implementor of `Runtime<S>` using single threaded Tokio runtime.
#[derive(Debug)]
pub struct CurrentThread {
    runtime: tokio::runtime::current_thread::Runtime,
}

impl CurrentThread {
    pub(crate) fn new() -> crate::Result<Self> {
        Ok(Self {
            runtime: tokio::runtime::current_thread::Runtime::new()?,
        })
    }

    fn block_on<F>(&mut self, mut future: F) -> crate::Result<F::Item>
    where
        F: Future,
        F::Error: Into<BoxedStdError>,
    {
        self.runtime.block_on(futures::future::poll_fn(move || {
            future.poll().map_err(crate::Error::from_boxed_compat)
        }))
    }
}

impl<S> Runtime<S> for CurrentThread where S: MakeTestService {}

impl<S> RuntimeImpl<S> for CurrentThread
where
    S: MakeTestService,
{
    fn make_service(&mut self, future: S::Future) -> crate::Result<S::Service> {
        self.block_on(future)
    }

    fn call(
        &mut self,
        future: <S::Service as TestService>::Future,
    ) -> crate::Result<Response<S::ResponseBody>> {
        self.block_on(future)
    }

    fn receive_body(&mut self, body: S::ResponseBody) -> crate::Result<Output> {
        self.block_on(Receive::new(body))
    }

    fn shutdown(mut self) {
        self.runtime.run().unwrap();
    }
}

#[allow(missing_debug_implementations)]
struct Receive<Bd> {
    state: ReceiveState<Bd>,
}

#[allow(missing_debug_implementations)]
enum ReceiveState<Bd> {
    Init(Option<Bd>),
    InFlight { body: Bd, chunks: Vec<Bytes> },
}

impl<Bd> Receive<Bd>
where
    Bd: ResponseBody,
{
    fn new(body: Bd) -> Self {
        Self {
            state: ReceiveState::Init(Some(body)),
        }
    }
}

impl<Bd> Future for Receive<Bd>
where
    Bd: ResponseBody,
{
    type Item = Output;
    type Error = Bd::Error;

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        loop {
            self.state = match self.state {
                ReceiveState::Init(ref mut body) => ReceiveState::InFlight {
                    body: body.take().expect("unexpected condition"),
                    chunks: vec![],
                },
                ReceiveState::InFlight {
                    ref mut body,
                    ref mut chunks,
                } => {
                    while let Some(chunk) = futures::try_ready!(body.poll_buf()) {
                        chunks.push(chunk.collect());
                    }
                    return Ok(Async::Ready(Output {
                        chunks: mem::replace(chunks, vec![]),
                    }));
                }
            }
        }
    }
}

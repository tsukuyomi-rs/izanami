use {
    crate::{
        async_result::AsyncResult,
        runtime::Runtime,
        server::Server,
        service::{
            imp::{ResponseBody, TestService},
            MakeTestService, MockRequestBody,
        },
    },
    bytes::{Buf, Bytes},
    futures::{Async, Future, Poll},
    http::{Request, Response},
    std::{borrow::Cow, str},
};

/// A type that simulates an established connection with a client.
#[derive(Debug)]
pub struct Client<'s, S: MakeTestService> {
    server: &'s mut Server<S>,
    service: S::Service,
}

impl<'s, S> Client<'s, S>
where
    S: MakeTestService,
{
    pub(crate) fn new(server: &'s mut Server<S>, service: S::Service) -> Self {
        Client { server, service }
    }

    /// Applies an HTTP request to this client and await its response.
    pub fn respond<Rt>(
        &mut self,
        request: Request<impl Into<MockRequestBody>>,
    ) -> impl AsyncResult<Rt, Output = ClientResponse<S>>
    where
        Rt: Runtime<<S::Service as TestService>::Future>,
    {
        let future = self.service.call(request.map(Into::into));
        crate::async_result::wait_fn(move |cx| {
            Ok(ClientResponse {
                inner: cx.block_on(future)?,
            })
        })
    }
}

/// A type that contains the result at the time when `S::Future` is resolved.
#[derive(Debug)]
pub struct ClientResponse<S: MakeTestService> {
    inner: Response<S::ResponseBody>,
}

impl<S> std::ops::Deref for ClientResponse<S>
where
    S: MakeTestService,
{
    type Target = Response<S::ResponseBody>;

    #[inline]
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl<S> std::ops::DerefMut for ClientResponse<S>
where
    S: MakeTestService,
{
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}

impl<S> ClientResponse<S>
where
    S: MakeTestService,
{
    pub fn into_inner(self) -> Response<S::ResponseBody> {
        self.inner
    }

    /// Convert itself into an instance of `AsyncResult` resolved as `ResponseData`.
    pub fn send_body<Rt>(self) -> impl AsyncResult<Rt, Output = ResponseData>
    where
        Rt: Runtime<SendResponseBody<S::ResponseBody>>,
    {
        let body = self.inner.into_body();
        SendResponseBody {
            state: SendResponseBodyState::Init(Some(body)),
        }
    }
}

#[doc(hidden)]
#[allow(missing_debug_implementations)]
pub struct SendResponseBody<Bd> {
    state: SendResponseBodyState<Bd>,
}

#[allow(missing_debug_implementations)]
enum SendResponseBodyState<Bd> {
    Init(Option<Bd>),
    InFlight { body: Bd, chunks: Vec<Bytes> },
}

impl<Bd> Future for SendResponseBody<Bd>
where
    Bd: ResponseBody,
{
    type Item = ResponseData;
    type Error = Bd::Error;

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        loop {
            self.state = match self.state {
                SendResponseBodyState::Init(ref mut body) => SendResponseBodyState::InFlight {
                    body: body.take().expect("unexpected condition"),
                    chunks: vec![],
                },
                SendResponseBodyState::InFlight {
                    ref mut body,
                    ref mut chunks,
                } => {
                    while let Some(chunk) = futures::try_ready!(body.poll_buf()) {
                        chunks.push(chunk.collect());
                    }
                    return Ok(Async::Ready(ResponseData {
                        chunks: std::mem::replace(chunks, vec![]),
                        _priv: (),
                    }));
                }
            }
        }
    }
}

/// A collection of data generated by the response body.
#[derive(Debug)]
pub struct ResponseData {
    pub chunks: Vec<Bytes>,
    _priv: (),
}

impl ResponseData {
    /// Returns a representation of the chunks as a byte sequence.
    pub fn to_bytes(&self) -> Cow<'_, [u8]> {
        match self.chunks.len() {
            0 => Cow::Borrowed(&[]),
            1 => Cow::Borrowed(&self.chunks[0]),
            _ => Cow::Owned(self.chunks.iter().fold(Vec::new(), |mut acc, chunk| {
                acc.extend_from_slice(&*chunk);
                acc
            })),
        }
    }

    /// Returns a representation of the chunks as an UTF-8 sequence.
    pub fn to_utf8(&self) -> Result<Cow<'_, str>, str::Utf8Error> {
        match self.to_bytes() {
            Cow::Borrowed(bytes) => str::from_utf8(bytes).map(Cow::Borrowed),
            Cow::Owned(bytes) => String::from_utf8(bytes)
                .map_err(|e| e.utf8_error())
                .map(Cow::Owned),
        }
    }
}

//! request/response bodies.

use {
    bytes::Buf,
    futures::{Async, Poll},
    http::HeaderMap,
    tokio_buf::{BufStream, SizeHint},
};

/// A trait that abstracts HTTP request/response bodies.
pub trait HttpBody {
    /// The type of bytes generated by this body.
    type Data: Buf;

    /// The error type that will be returned from this body.
    type Error;

    /// Polls the next data of this body.
    fn poll_data(&mut self) -> Poll<Option<Self::Data>, Self::Error>;

    /// Returns the hint of remaining length of data.
    fn size_hint(&self) -> SizeHint {
        SizeHint::new()
    }

    /// Polls the trailing header map of this body.
    fn poll_trailers(&mut self) -> Poll<Option<HeaderMap>, Self::Error> {
        Ok(Async::Ready(None))
    }

    /// Returns whether the body has been completed emitting all chunks and trailer headers.
    ///
    /// It is possible that this method returns `false`
    /// even if the body has incomplete chunks or trailers.
    fn is_end_stream(&self) -> bool {
        false
    }

    #[doc(hidden)]
    fn content_length(&self) -> Option<u64> {
        None
    }
}

impl<T: BufStream> HttpBody for T {
    type Data = T::Item;
    type Error = T::Error;

    fn poll_data(&mut self) -> Poll<Option<Self::Data>, Self::Error> {
        BufStream::poll_buf(self)
    }

    fn size_hint(&self) -> SizeHint {
        BufStream::size_hint(self)
    }

    fn poll_trailers(&mut self) -> Poll<Option<HeaderMap>, Self::Error> {
        Ok(Async::Ready(None))
    }

    fn is_end_stream(&self) -> bool {
        let hint = self.size_hint();
        hint.upper()
            .map(|u| u == 0 && u == hint.lower())
            .unwrap_or(false)
    }
}

// ===== HttpBodyExt =====

/// An extension trait for adding some adaptor methods to `HttpBody`s.
pub trait HttpBodyExt: HttpBody {
    /// Lift this body into a `BufStream`.
    fn into_buf_stream(self) -> IntoBufStream<Self>
    where
        Self: Sized,
    {
        IntoBufStream { inner: self }
    }
}

impl<T: HttpBody> HttpBodyExt for T {}

/// A wrapper for `HttpBody` for lifting the instance into a `BufStream`.
#[derive(Debug)]
pub struct IntoBufStream<T: HttpBody> {
    inner: T,
}

impl<T: HttpBody> BufStream for IntoBufStream<T> {
    type Item = T::Data;
    type Error = T::Error;

    #[inline]
    fn poll_buf(&mut self) -> Poll<Option<Self::Item>, Self::Error> {
        HttpBody::poll_data(&mut self.inner)
    }

    #[inline]
    fn size_hint(&self) -> SizeHint {
        HttpBody::size_hint(&self.inner)
    }
}

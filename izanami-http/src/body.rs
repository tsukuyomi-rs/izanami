//! request/response bodies.

use {
    bytes::Buf,
    futures::{Async, Poll},
    http::HeaderMap,
    tokio_buf::{BufStream, SizeHint},
};

/// A trait that abstracts HTTP request/response bodies.
pub trait HttpBody {
    /// The type of bytes generated by this body.
    type Data: Buf;

    /// The error type that will be returned from this body.
    type Error;

    /// Polls the next data of this body.
    fn poll_data(&mut self) -> Poll<Option<Self::Data>, Self::Error>;

    /// Returns the hint of remaining length of data.
    fn size_hint(&self) -> SizeHint {
        SizeHint::new()
    }

    /// Polls the trailing header map of this body.
    fn poll_trailers(&mut self) -> Poll<Option<HeaderMap>, Self::Error> {
        Ok(Async::Ready(None))
    }

    /// Returns whether the body has been completed emitting all chunks and trailer headers.
    ///
    /// It is possible that this method returns `false`
    /// even if the body has incomplete chunks or trailers.
    fn is_end_stream(&self) -> bool {
        false
    }

    #[doc(hidden)]
    fn content_length(&self) -> Option<u64> {
        None
    }
}

impl<T> HttpBody for T
where
    T: BufStream + AsRef<[u8]>,
{
    type Data = T::Item;
    type Error = T::Error;

    fn poll_data(&mut self) -> Poll<Option<Self::Data>, Self::Error> {
        BufStream::poll_buf(self)
    }

    fn size_hint(&self) -> SizeHint {
        BufStream::size_hint(self)
    }

    fn poll_trailers(&mut self) -> Poll<Option<HeaderMap>, Self::Error> {
        Ok(Async::Ready(None))
    }

    fn is_end_stream(&self) -> bool {
        self.as_ref().is_empty()
    }

    fn content_length(&self) -> Option<u64> {
        Some(self.as_ref().len() as u64)
    }
}

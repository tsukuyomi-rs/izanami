//! request/response bodies.

use {
    bytes::{Buf, Bytes},
    futures::{Async, Poll, Stream},
    http::HeaderMap,
    izanami_util::MapAsyncOptExt,
    std::fmt,
    tokio_buf::{BufStream, SizeHint},
};

/// A trait that abstracts HTTP request/response bodies.
pub trait HttpBody {
    /// The type of bytes generated by this body.
    type Data: Buf;

    /// The error type that will be returned from this body.
    type Error;

    /// Polls the next data of this body.
    fn poll_data(&mut self) -> Poll<Option<Self::Data>, Self::Error>;

    /// Returns the hint of remaining length of data.
    fn size_hint(&self) -> SizeHint {
        SizeHint::new()
    }

    /// Polls the trailing header map of this body.
    fn poll_trailers(&mut self) -> Poll<Option<HeaderMap>, Self::Error> {
        Ok(Async::Ready(None))
    }

    /// Returns whether the body has been completed emitting all chunks and trailer headers.
    ///
    /// It is possible that this method returns `false`
    /// even if the body has incomplete chunks or trailers.
    fn is_end_stream(&self) -> bool {
        false
    }

    /// Returns the length of total bytes contained in this body.
    fn content_length(&self) -> Option<u64> {
        let hint = self.size_hint();
        match hint.upper() {
            Some(u) if u == hint.lower() => Some(u),
            _ => None,
        }
    }
}

impl<T: BufStream> HttpBody for T {
    type Data = T::Item;
    type Error = T::Error;

    fn poll_data(&mut self) -> Poll<Option<Self::Data>, Self::Error> {
        BufStream::poll_buf(self)
    }

    fn size_hint(&self) -> SizeHint {
        BufStream::size_hint(self)
    }

    fn poll_trailers(&mut self) -> Poll<Option<HeaderMap>, Self::Error> {
        Ok(Async::Ready(None))
    }

    fn is_end_stream(&self) -> bool {
        let hint = self.size_hint();
        hint.upper()
            .map(|u| u == 0 && u == hint.lower())
            .unwrap_or(false)
    }
}

// ===== HttpBodyExt =====

/// An extension trait for adding some adaptor methods to `HttpBody`s.
pub trait HttpBodyExt: HttpBody {
    /// Lift this body into a `BufStream`.
    fn into_buf_stream(self) -> IntoBufStream<Self>
    where
        Self: Sized,
    {
        IntoBufStream { inner: self }
    }
}

impl<T: HttpBody> HttpBodyExt for T {}

/// A wrapper for `HttpBody` for lifting the instance into a `BufStream`.
#[derive(Debug)]
pub struct IntoBufStream<T: HttpBody> {
    inner: T,
}

impl<T: HttpBody> BufStream for IntoBufStream<T> {
    type Item = T::Data;
    type Error = T::Error;

    #[inline]
    fn poll_buf(&mut self) -> Poll<Option<Self::Item>, Self::Error> {
        HttpBody::poll_data(&mut self.inner)
    }

    #[inline]
    fn size_hint(&self) -> SizeHint {
        HttpBody::size_hint(&self.inner)
    }
}

// ===== ResponseBody =====

/// An implementation of `HttpBody` for general purpose.
#[derive(Debug)]
pub struct Body(Inner);

trait BoxedBufStream: Send + 'static {
    fn poll_buf(&mut self) -> Poll<Option<Data>, Error>;
    fn size_hint(&self) -> SizeHint;
}

enum Inner {
    Empty,
    Sized(Option<Bytes>),
    Chunked(Box<dyn BoxedBufStream>),
}

impl fmt::Debug for Inner {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Inner::Empty => f.debug_struct("Empty").finish(),
            Inner::Sized(..) => f.debug_struct("Sized").finish(),
            Inner::Chunked(..) => f.debug_struct("Chunked").finish(),
        }
    }
}

impl Default for Body {
    fn default() -> Self {
        Self::empty()
    }
}

impl Body {
    /// Creates an empty `Body`.
    #[inline]
    pub fn empty() -> Self {
        Body(Inner::Empty)
    }

    /// Wraps a `Stream` into a `Body`.
    pub fn wrap_stream<S>(stream: S) -> Self
    where
        S: Stream<Item = Data> + Send + 'static,
        S::Error: Into<BoxedStdError>,
    {
        struct WrapStream<S>(S);

        impl<S> BoxedBufStream for WrapStream<S>
        where
            S: Stream + Send + 'static,
            S::Item: Into<Data>,
            S::Error: Into<BoxedStdError>,
        {
            fn poll_buf(&mut self) -> Poll<Option<Data>, Error> {
                self.0
                    .poll()
                    .map_async_opt(Into::into)
                    .map_err(Error::from_std)
            }

            fn size_hint(&self) -> SizeHint {
                SizeHint::new()
            }
        }

        Body(Inner::Chunked(Box::new(WrapStream(stream))))
    }

    /// Wraps a `BufStream` into a `Body`.
    pub fn wrap_buf_stream<S>(buf_stream: S) -> Self
    where
        S: BufStream + Send + 'static,
        S::Item: Send + 'static,
        S::Error: Into<BoxedStdError>,
    {
        struct WrapBufStream<S>(S);

        impl<S> BoxedBufStream for WrapBufStream<S>
        where
            S: BufStream + Send + 'static,
            S::Item: Send + 'static,
            S::Error: Into<BoxedStdError>,
        {
            fn poll_buf(&mut self) -> Poll<Option<Data>, Error> {
                self.0
                    .poll_buf()
                    .map_async_opt(Data::from_buf)
                    .map_err(Error::from_std)
            }

            fn size_hint(&self) -> SizeHint {
                SizeHint::new()
            }
        }

        Body(Inner::Chunked(Box::new(WrapBufStream(buf_stream))))
    }
}

impl From<()> for Body {
    fn from(_: ()) -> Self {
        Body::empty()
    }
}

macro_rules! impl_response_body {
    ($($t:ty,)*) => {$(
        impl From<$t> for Body {
            fn from(body: $t) -> Self {
                Body(Inner::Sized(Some(body.into())))
            }
        }
    )*};
}

impl_response_body! {
    &'static str,
    &'static [u8],
    String,
    Vec<u8>,
    bytes::Bytes,
    //std::borrow::Cow<'static, str>,
    //std::borrow::Cow<'static, [u8]>,
}

impl HttpBody for Body {
    type Data = Data;
    type Error = Error;

    fn poll_data(&mut self) -> Poll<Option<Self::Data>, Self::Error> {
        match self.0 {
            Inner::Empty => Ok(Async::Ready(None)),
            Inner::Sized(ref mut data) => Ok(Async::Ready(data.take().map(Into::into))),
            Inner::Chunked(ref mut chunks) => chunks.poll_buf(),
        }
    }

    fn size_hint(&self) -> SizeHint {
        let mut hint = SizeHint::new();
        match self.0 {
            Inner::Empty => hint.set_upper(0),
            Inner::Sized(Some(ref data)) => hint.set_upper(data.len() as u64),
            Inner::Sized(..) => (),
            Inner::Chunked(..) => (),
        }
        hint
    }

    // TODO: trailers support.
    fn poll_trailers(&mut self) -> Poll<Option<HeaderMap>, Self::Error> {
        Ok(Async::Ready(None))
    }

    fn is_end_stream(&self) -> bool {
        match self.0 {
            Inner::Empty => true,
            Inner::Sized(ref data) => data.as_ref().map_or(true, |data| data.is_empty()),
            Inner::Chunked(..) => false,
        }
    }

    fn content_length(&self) -> Option<u64> {
        match self.0 {
            Inner::Empty => None,
            Inner::Sized(Some(ref data)) => Some(data.len() as u64),
            _ => None,
        }
    }
}

// ===== Data =====

/// A chunk of bytes produced by `ResponseBody`.
#[derive(Debug)]
pub struct Data(DataInner);

enum DataInner {
    Bytes(Bytes),
    Boxed(Box<dyn Buf + Send + 'static>),
}

impl fmt::Debug for DataInner {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DataInner::Bytes(..) => f.debug_struct("Bytes").finish(),
            DataInner::Boxed(..) => f.debug_struct("Boxed").finish(),
        }
    }
}

impl Data {
    #[allow(missing_docs)]
    pub fn from_buf<B>(data: B) -> Self
    where
        B: Buf + Send + 'static,
    {
        Data(DataInner::Boxed(Box::new(data)))
    }
}

impl From<Bytes> for Data {
    fn from(data: Bytes) -> Self {
        Data(DataInner::Bytes(data))
    }
}

impl Buf for Data {
    fn remaining(&self) -> usize {
        match self.0 {
            DataInner::Bytes(ref data) => data.len(),
            DataInner::Boxed(ref data) => data.remaining(),
        }
    }

    fn bytes(&self) -> &[u8] {
        match self.0 {
            DataInner::Bytes(ref data) => data.as_ref(),
            DataInner::Boxed(ref data) => data.bytes(),
        }
    }

    fn advance(&mut self, cnt: usize) {
        match self.0 {
            DataInner::Bytes(ref mut data) => data.advance(cnt),
            DataInner::Boxed(ref mut data) => data.advance(cnt),
        }
    }
}

type BoxedStdError = Box<dyn std::error::Error + Send + Sync + 'static>;

/// The type of error values caused by `Body`.
#[derive(Debug)]
pub struct Error(BoxedStdError);

impl Error {
    fn from_std(err: impl Into<BoxedStdError>) -> Self {
        Error(err.into())
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        Some(&*self.0)
    }
}
